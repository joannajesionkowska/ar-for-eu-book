<!DOCTYPE html>
<html>

  ﻿<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Programming</title>
    <meta name="description" content="The Open Augmented Reality Teaching Book">

    <link rel="stylesheet" href="/ar-for-eu-book/css/main.css">
    <link rel="canonical" href="https://klamma.github.io/ar-for-eu-book/chapter/prog/">
    <link rel="alternate" type="application/rss+xml" title="The Open Augmented Reality Teaching Book" href="https://klamma.github.io/ar-for-eu-book/feed.xml">

    <!-- Favicon head tag -->
    <link rel="shortcut icon" href="/ar-for-eu-book/favicon.ico" type="image/x-icon">

    <!-- Visualization Libraries -->
    <script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
    <script src="https://code.highcharts.com/highcharts.js"></script>
    <script src="https://code.highcharts.com/highcharts-more.js"></script>
    <script src="https://code.highcharts.com/modules/exporting.js"></script>

    <!-- formula rendering -->
    <script type="text/javascript" async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/ar-for-eu-book/">The Open Augmented Reality Teaching Book</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
	  <a class="page-link" href="https://codereality.net/">Code Reality</a>
          <a class="page-link" href="/ar-for-eu-book/posts">Blog Posts</a>
          <a class="page-link" href="/ar-for-eu-book/toc">Table of Content</a>
          <a class="page-link" href="/ar-for-eu-book/references">Bibliography</a>
          <a class="page-link" href="/ar-for-eu-book/contrib">Contributors</a>
          <a class="page-link" href="/ar-for-eu-book/about">About</a>
      </div>
    </nav>

  </div>

</header>



    <div class="page-content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Programming</h1>
  </header>

  <div class="post-content">
    <h2 id="which-programming-language-should-i-learn-to-get-started-with-ar-development">Which Programming Language Should I Learn to get Started With AR Development?</h2>

<p>There are different technologies and engines available to create AR applications.
One option is the 3D engine Unity where application logic can be implemented in <em>C#</em> <a class="citation" href="#Ferr19b">(Ferrone, March 2019)</a>.</p>

<p>When using the Unreal Engine, implementations can be done in <em>C++</em> <a class="citation" href="#DSWh19">(Doran et al., 2019)</a>.
However, C++ is not an essential prerequisite for the Unreal Engine as it also provides a visual scripting language called <em>Blueprint</em> <a class="citation" href="#Ferr19c">(Ferro, 2019)</a>.</p>

<p>Another option is to develop AR experiences for the Web.
In this case, you should study Web technologies and the scripting language <em>JavaScript</em>.</p>

<h2 id="SOLID">SOLID Principles of Code</h2>

<p>The SOLID principles of code describe a set of five rules and guidelines which should improve the quality of written code <a class="citation" href="#Mart03">(Martin, 2003)</a>.
Designed as a general guide, the rules also apply to Unity scripts.
In this special case they help with structuring the application logic into classes.</p>

<h3 id="s-single-responsibility">S: Single Responsibility</h3>
<p>Every class or component should be responsible for only a single part of functionality.
This way, a script only needs to be adapted if the one feature that it realized needs to be changed <a class="citation" href="#Mart03">(Martin, 2003)</a>.
This approach leads to readable code.
Instead of a few big classes, which are responsible for many different things, the result is a large amount of small, readable classes with defined tasks.
Additionally, such small classes, which focus on one subfeature, are reusable if this subfeature is also required in another context in the application.
Since the classes have a defined responsibility, it is less cumbersome to create behaviour variants since they can be realized by inheritance or by modifying the corresponding class.</p>

<p>As an example, we assume that we need to build a virtual lift.
It consists of a 3D model of its car and the lift shaft.
The lift car is equipped with animated doors that can open and close, as well as a series of buttons for each floor.
Additionally, a set of floors has been created which also have a button to call the lift.
The Single Responsibility principle is violated if the behaviour for the lift is implemented in one large class, which controls the floor selection, movement and door animation.
Instead, for each of these features, a separate class should be created.
For instance, one dedicated class is concerned with moving the lift up and down to the floors.
Another class controls the doors and makes sure that they only open when the lift is stationary at the floors.
For handling the input from a button, a different class can be implemented.
The logic for selecting in which order floors should be served can be implemented in a fourth class.</p>

<h3 id="o-open-closed-principle">O: Open-Closed Principle</h3>
<p>The open-closed principles states that classes should be designed in a way that they are open for extension but closed for modification <a class="citation" href="#Mart03">(Martin, 2003)</a>.
This means that the class should be extendable by new details, e.g. a varied behaviour.
However, such details do not affect the general functionality of the class and therefore it should be possible to include them without modifying the class.
Especially classes from software libraries need to follow this principle.
If the library is only available in its compiled form, developers cannot modify it.
However, new features can still be added to the class’s functionality by inheriting from the library class.</p>

<p>Imagine a test application for courses which asks the user questions and in the end it should process the answers into a final score or grade.
Since the application should be used in different courses with various grading schemes, variants for the scoring of answers are required.
For instance, one course rewards points for correct answers but gives zero points for errors.
In another course, wrong answers deduct points from the total.
The program contains an assessment class which administers the answers to the quiz questions, checks them and converts them to points for the final score.
If the different grading schemes are realized in this class using a case distinction, the class has to be edited for each new score calculation.
This can be seen in the example class <code class="highlighter-rouge">Assessment1</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>/// Assessment1 violates the open-closed principle.
public class Assessment1
{
	private Answer[] answers;
	...
	public int CalculateFinalScore(int gradingSchemeIndex)
	{
		int totalPoints = 0;

		for (int i=0; i &lt; answers.Length;i++)
		{
			switch(gradingSchemeIndex)
			{
				case 0: // no points for wrong answers
					if (answers[i].IsCorrect)
					{
						totalPoints += answers[i].Points;
					}
					else
					{
						totalPoints += 0;
					}
					break;
				case 1: // point deductions for wrong answers
					if (answers[i].IsCorrect)
					{
						totalPoints += answers[i].Points;
					}
					else
					{
						totalPoints -= answers[i].Points;
					}
					break;
				case ... // more calculation methods
				default:
					System.out.println("Undefined Grading Scheme.")
			}
		}

		return totalPoints;
	}
}
</code></pre>
</div>

<p>To follow the open-closed principle, an interface IPointCalculator is introduced which gives access to a score calculation method.
Each grading scheme is refactored into an own class which implements this interface.
Thus, the assessment class can access the interface and does not need to know how the points are calculated in detail.
New variations can be added by creating new classes and the assessment class does not need to be altered.
One can switch between the grading schemes by setting the pointCalculator object to an instance of a specific class which implements the interface, e.g. <code class="highlighter-rouge">pointCalculator = new ZeroPointsForWrongAnswer()</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class Assessment2
{
	private Answer[] answers;
	private IPointCalculator pointCalculator;
	...

	public int CalculateFinalScore()
	{
		int totalPoints = 0;

		for (int i=0; i &lt; answers.Length;i++)
		{
			points += pointCalculator.GetAnswerScore(answers[i]);
		}

		return totalPoints;
	}
}

public interface IPointCalculator
{
	int GetAnswerScore(Answer answer);
}

public class ZeroPointsForWrongAnswer : IPointCalculator
{
	public int GetAnswerScore(Answer answer)
	{
		if (answer.IsCorrect)
		{
			return answer.Points;
		}
		else
		{
			return 0;
		}
	}
}

public class DeductionsForWrongAnswer : IPointCalculator
{
	public int GetAnswerScore(Answer answer)
	{
		if (answer.IsCorrect)
		{
			return answer.Points;
		}
		else
		{
			return -answer.Points;
		}
	}
}
</code></pre>
</div>

<p>In general, the open-closed principle can be realized by using inheritance, abstract classes, interfaces and delegate methods.</p>

<h3 id="l-liskov-substitution-principle">L: Liskov Substitution Principle</h3>

<p>The Liskov substitution principle describes that if a class A has a property P then anay child class B of A must also have the property P <a class="citation" href="#Mart03">(Martin, 2003)</a>.
An implication of this is that any class that references an object of type A can also work with instances of type B without knowing about the specific type.</p>

<p>The Liskov substitution principle can be used to verify that an inheritance between two classes is actually well modelled.
When designing a programme architecture, developers usually try to find “is a”-relationships which are then modelled using inheritance.
For instance, assume that we would like to model an application, which simulates the behaviour of cats.
The application should support and distinguish different breeds of cats, e.g. the Persian cat.
Since a Persian cat is a cat, one can model this with a superclass <code class="highlighter-rouge">Cat</code> and a child class <code class="highlighter-rouge">PersianCat</code>.
The superclass holds all properties and logic, which are common with cats, e.g. their age, height, fur or eye colour.
In addition to this, the application also contains an object <code class="highlighter-rouge">Brush</code> with a function <code class="highlighter-rouge">Groom</code>.
We want to groom all implemented breeds of cats and so the function takes an object of type <code class="highlighter-rouge">Cat</code> as input and returns a cat with groomed fur.
Once this implementation is finished, we add new breeds to the application, e.g. European shorthairs and Sphynx cats.
With the European shorthairs, everything still works fine but with the Sphynx cats, there is an error.
Sphynx cats are hairless cats which means that the <code class="highlighter-rouge">Groom</code> function does not make sense for these cats.
However, the <code class="highlighter-rouge">Groom</code> function takes a generic <code class="highlighter-rouge">Cat</code> as input which means that Sphynx cats are allowed as input.
The bad way to fix this is to create a case distinction in the <code class="highlighter-rouge">Groom</code> function:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>public Cat Groom(Cat inputCat)
{
	if (inputCat instance of Sphynx)
	{
		// do not groom hairless cats
		return inputCat;
	}
	else
	{
		// perform grooming procedure
		...
	}
}
</code></pre>
</div>
<p>This solution violates the Liskov substitution principle because now the <code class="highlighter-rouge">Groom</code> function cannot just work with any cat type but needs to know which specific subtype the cat object has.
The violation is caused by incorrect assumptions about cats, e.g. that all of them have fur.
If further hairless cats like the Ukrainian Levkoy are added to the application, they also require separate case distinctions.
Instead, a better solution is to refactor the inheritance hierarchy.
In this case, a <code class="highlighter-rouge">Cat</code> superclass can be created with the child classes <code class="highlighter-rouge">HairlessCat</code> and <code class="highlighter-rouge">CatWithHair</code>.
The cat breeds are children of one of these two classes.
This way, the <code class="highlighter-rouge">Groom</code> function can now expect a <code class="highlighter-rouge">CatWithHair</code> object as input.</p>

<h3 id="i-interface-segregation-principle">I: Interface Segregation Principle</h3>

<p>The interface segregation principle states that interfaces should be granular.
Hence, a class that implements the interface never has to include additional methods, which are defined in the interface but which are not used <a class="citation" href="#Mart03">(Martin, 2003)</a>.
This means that large interfaces, which are used for different purposes of clients, should be split into smaller interfaces.
These smaller interfaces should group the methods, which are relevant in a specific context.</p>

<p>An example for a violation of the interface segregation principle is an <code class="highlighter-rouge">IButton</code> interface.
Classes which implement this interface must contain all methods that make it an interactive button, e.g. <code class="highlighter-rouge">OnFocusEnter()</code>, <code class="highlighter-rouge">OnFocusExit()</code>, <code class="highlighter-rouge">OnClick()</code>.
The problem of this interface is that it combines the two concepts of reacting to user focus, i.e. pointing at the button with an input device, and the interaction with the button in the form of a click.
If an interactive element should be created which should rotate on focus but has no other interactive features, the <code class="highlighter-rouge">IButton</code> interface is not suitable.
It can be implemented by a class that models the behaviour of such an element but this means that the <code class="highlighter-rouge">OnClick()</code> method will be left empty.
Instead, a better solution is to separate the different properties, which are described by the interface.
There can be an interface <code class="highlighter-rouge">IFocusable</code>.
Elements that should react to user focus can implement this interface.
Additionally, an interface <code class="highlighter-rouge">IInputHandler</code> can be defined for elements that should also react to input events.</p>

<h3 id="d-dependency-inversion-principle">D: Dependency Inversion Principle</h3>

<p>A common practise is to layer classes and modules in a way that higher-level classes access functionality from lower-level classes.
An example for this can be seen in the following simplified architecture for I/O operations in a programme, which violates the dependency inversion principle.
On the lowest level, there is an <code class="highlighter-rouge">IOOperations</code> class which takes byte data and writes them to a file.
In this process, it handles the operations on the file system such as creating the file, locking it, writing data and unlocking it.
One level higher, an <code class="highlighter-rouge">Encoding</code> class handles the conversion of the in-memory data to the byte save data.
It takes some input text, converts it to byte data and adds the corresponding byte headers.
To write the byte data to the disk, it calls the write function which is implemented in <code class="highlighter-rouge">IOOperations</code> one level lower.
On the highest level, a <code class="highlighter-rouge">Save</code> module fetches the application’s data which need to be saved.
If it needs to save text, e.g. which has been entered by the user, it passes the text to the <code class="highlighter-rouge">Encoding</code> class which will turn it into bytes.
In turn, the <code class="highlighter-rouge">Encoding</code> class will pass the byte data to the <code class="highlighter-rouge">IOOperations</code> class.</p>

<p>This architecture violates the dependency inversion principle because it states that higher modules should not depend on lower modules <a class="citation" href="#Mart03">(Martin, 2003)</a>.
In this case, the <code class="highlighter-rouge">Save</code> module depends on the <code class="highlighter-rouge">Enconding</code> class by calling its methods and <code class="highlighter-rouge">Enconding</code> depends on <code class="highlighter-rouge">IOOperations</code>.
If the architecture is changed, e.g. it is decided to re-name the write-function in the <code class="highlighter-rouge">IOOperations</code> class, this means that the <code class="highlighter-rouge">Encoding</code> class must also be altered.</p>

<p>A solution is that the high-level class defines an interface.
The high-level class only works with this abstract description.
The low-level class now needs to implement this interface.
Hence, the dependency is inverted.
The low-level class now depends on the interface definitions, which are defined by the high-level class.
In the example, the two interfaces <code class="highlighter-rouge">IFileWriter</code> and <code class="highlighter-rouge">IEnconder</code> are added.
<code class="highlighter-rouge">IFileWriter</code> is used by the <code class="highlighter-rouge">Enconding</code> class to write content to the disk.
<code class="highlighter-rouge">IOOperations</code> now needs to be an implementation of <code class="highlighter-rouge">IFileWriter</code>.
Similarly, the interface <code class="highlighter-rouge">IEncoder</code> is used by the <code class="highlighter-rouge">Save</code> module to encode the content.
The specific implementation of the interface is provided by the <code class="highlighter-rouge">Encoding</code> class.</p>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The Open Augmented Reality Teaching Book</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>The Open Augmented Reality Teaching Book</li>
          <li><a href="mailto:klamma@dbis.rwth-aachen.de">klamma@dbis.rwth-aachen.de</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          <li>
            <a href="https://twitter.com/AR_FOR_EU"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">AR_FOR_EU</span></a>

          </li>
          <li>
            <a href="/ar-for-eu-book/feed.xml"><span class="icon icon-rss"><?xml version="1.0"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"> 
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="128px" height="128px" id="RSSicon" viewBox="0 0 256 256">
<defs>
<linearGradient x1="0.085" y1="0.085" x2="0.915" y2="0.915" id="RSSg">
<stop  offset="0.0" stop-color="#E3702D"/><stop  offset="0.1071" stop-color="#EA7D31"/>
<stop  offset="0.3503" stop-color="#F69537"/><stop  offset="0.5" stop-color="#FB9E3A"/>
<stop  offset="0.7016" stop-color="#EA7C31"/><stop  offset="0.8866" stop-color="#DE642B"/>
<stop  offset="1.0" stop-color="#D95B29"/>
</linearGradient>
</defs>
<rect width="256" height="256" rx="55" ry="55" x="0"  y="0"  fill="#CC5D15"/>
<rect width="246" height="246" rx="50" ry="50" x="5"  y="5"  fill="#F49C52"/>
<rect width="236" height="236" rx="47" ry="47" x="10" y="10" fill="url(#RSSg)"/>
<circle cx="68" cy="189" r="24" fill="#FFF"/>
<path d="M160 213h-34a82 82 0 0 0 -82 -82v-34a116 116 0 0 1 116 116z" fill="#FFF"/>
<path d="M184 213A140 140 0 0 0 44 73 V 38a175 175 0 0 1 175 175z" fill="#FFF"/>
</svg>
</span><span class="username">Subscribe</span></a>

          </li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The Open Augmented Reality Teaching Book</p>
      </div>
    </div>

  </div>

</footer>


    <!-- load visualizations (at the end so that the div elements are known here) -->
    
  </body>

</html>
